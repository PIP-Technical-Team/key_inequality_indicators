---
title: 'Key Inequality Indicators'
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    social: menu
    theme: paper
      # version: 4
      # #primary: "#FFF"
      # #navbar-bg: "#22A6F5"
      # base_font: 
      #   google: Lato
      # heading_font:
      #   google: Lato
      # code_font:
      #   google: 
      #     # arguments to sass::font_google() 
      #     family: Lato
      #     local: false
runtime: shiny
resource_files:
- data/CLASS.dta
- data/CLASS.dta
---


```{r}
htmltools::includeHTML("custom_header.html")

```




```{r setup-packages, include=FALSE}
library("tidyverse")
library("rlang")
library("here")
library("data.table")
library("plotly")
library("flexdashboard")  
library("joyn")
library("gghighlight")
library("DT")
library("zoo")
library("RColorBrewer")
library("collapse")
```


```{r colorbrewer-defaults}

scale_colour_brewer_d <- function(..., palette = "Dark2") {
  scale_colour_brewer(..., palette = palette )
}

scale_fill_brewer_d <- function(..., palette = "Dark2") {
  scale_fill_brewer(..., palette = palette)
}

options(
  ggplot2.discrete.colour = scale_colour_brewer_d,
  ggplot2.discrete.fill = scale_fill_brewer_d
)

```


```{r setup-data, include=FALSE}
source_text <- paste("Source: World Bank, Poverty and Inequality Platform (version 20230919_2017).")

# Total pip output

# Step 1: data ----
dt_pip <- pipr::get_stats() |> 
  qDT()# as data.table
dt_pip[
  , 
  `:=`(
    top_10_bottom_40_ratio = (decile10)/(decile1 + decile2 + decile3 + decile4), 
    top_20_bottom_20_ratio = (decile10+decile9)/(decile1 + decile2)
  )
]
dt_pip[, 
       gini := gini*100]


# Step 2: creating general objects ----
pip_countries <- unique(dt_pip$country_name) # list of countries
pip_countries_multiple_welfare_type <- 
  dt_pip[, 
         if(.N>1) .SD, 
         by = .(country_name, year, welfare_type)
         ]$country_name |>
  unique()

pip_countries_multiple_reporting_level <- 
  dt_pip[, 
         if(.N > 1) 
           .SD, 
         by = .(country_name, year, reporting_level)
         ]$country_name |> 
  unique()

pip_countries_regions <- 
  unique(dt_pip, 
         by = c("country_name", "region_code")
         )[, 
           .(country_name, region_code, region_name)
           ]
region_matching <- unique(
  dt_pip[
    ,
    .(region_name), 
    by = region_code
  ]
)
# Exclude double rows
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[!reporting_level == "rural"] 
          } else {
            .SD
            }, 
         by = .(country_name, year, welfare_type)
         ][, 
           if (.N > 1) {
             .SD[reporting_level == "national"] 
             } else {
               .SD
               }, 
           by = .(country_name, year, welfare_type)
           ]
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[welfare_type == "income"] 
           } else {
             .SD
             }, 
         by = .(country_name, year, reporting_level)
         ]
# make deciles percentages
dec_cols <- paste0("decile", 1:10)

# Multiply each decile column by 100
dt_pip[, (paste0("decile", 1:10)) := lapply(.SD, function(x) x * 100), .SDcols = paste0("decile", 1:10)]

# Income groups
dt_class <- haven::read_dta(
  here::here("data", "CLASS.dta")
)
dt_class <- dt_class |> 
  as.data.table() |> 
  unique(
    by = c("economy", "incgroup_current")
  )
# Clean country names
dt_class[
  38, 
  economy := "Cote d'Ivoire"
]
dt_class[
  179, 
  economy := "Sao Tome and Principe"
]
dt_class[
  198, 
  economy := "Turkiye"
]
dt_pip <- joyn::joyn(
  x = dt_pip, 
  y = dt_class, 
  by = c("country_code = code"), 
  keep = "left", 
  match_type = "m:1",
  #y_vars_to_keep = "incgroup_current", 
  reportvar = FALSE
)
```

```{r create-high-ineq}
dt_ineq <- joyn::joyn(
  dt_pip |> 
  fsubset(year >= 2000 & year <= 2022) |>
    distinct(country_name, 
             country_code, 
             region_code, 
             region_name, 
             reporting_level,
             welfare_type, 
             incgroup_current, 
             fcv_current, 
             ida_current) |>
    crossing(year = 2000:2022), 
  dt_pip |> 
  fsubset(year >= 2000 & year <= 2022), 
  match_type = "1:1",
  by = c("country_code", 
         "year", 
         "reporting_level", 
         "welfare_type"), 
  verbose = FALSE)

dt_ineq <- dt_ineq  |>
  fgroup_by(country_code) |>
  fmutate(
    giniever = gini,
    giniever = na.locf(giniever, na.rm = FALSE), # Forward fill
    giniever = na.fill(giniever, fill = NA) # Ensure no trailing NAs
  ) |>
  fmutate(
    giniever = na.locf(giniever, fromLast = TRUE) # Backward fill
  ) |> 
  fungroup() |> 
  fselect( country_code, year, region_code, region_name, welfare_time, welfare_type, gini, 
         incgroup_current, ida_current, fcv_current, giniever) |>
  fmutate(highinequality = giniever > 0.40) |> 
  fmutate(ineq_type = fifelse(giniever < 30 , "Low inequality (<30)",
                             fifelse(giniever > 40, "High inequality (>40)", 
                                     "Moderate inequality (30-40)"))) |> 
  fmutate(country_count = 1L) |> 
  fmutate(incgroup_current = factor(incgroup_current, 
                                    levels = c("Low income", 
                                               "Lower middle income", 
                                               "Upper middle income", 
                                               "High income")))

# dt_ineq |>
#   fmutate(
#     giniever = gini,
#     giniever = na.locf(giniever, na.rm = FALSE), # Forward fill
#     giniever = na.fill(giniever, fill = NA) # Ensure no trailing NAs
#   ) |>
#   mutate(
#     giniever = na.locf(giniever, fromLast = TRUE) # Backward fill
#   ) |>
```



```{r load-data-functions}

downloadButtonRmd <- function (outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
 }

title_function <- function(ind){
  
  title_lookup <- c("Mean", 
                    "Median", 
                    "Gini", 
                    "MLD", 
                    paste0("Decile", 1:10),
                    "Top 10 Bottom 40 Ratio", 
                    "Top 20 Bottom 20 Ratio"
  )
  
  title_use_vec <- c(
    "Mean (daily per capita, 2017 $PPP)", 
    "Median (daily per capita, 2017 $PPP)", 
    "Gini index (0-100)",
    "MLD (mean log deviation)", 
    paste0("Decile", paste0(1:10, " welfare share (percent)")), 
    "Ratio of top 10 to bottom 40 share", 
    "Ratio of top 20 to bottom 20 share"
  )
  
  use_title <- title_use_vec[
    which(
      title_lookup %chin% ind
    )
  ]
  
  return(use_title)
  
}


create_data_imputed_by_countries <- function(
    dt, 
    countries_selected  = c("South Africa", "Colombia", "United States"), 
    year_selected       = 1998, 
    indicator           = c("Gini"), 
    window_length       = 2 
    
){
  
  # Argument Checks ----
  stopifnot(is.data.table(dt))
  if(
    is.null(countries_selected) | 
    is.null(year)               | 
    is.null(indicator)
  ) stop ( "Must choose" )
  if(
    length(year) > 1            | 
    length(indicator) > 1 
  ) stop ( "Can only select one year and one indicator" )
  
  # Use copy of dt
  dt_use <- copy( dt )
  
  indicator <- indicator |> 
    str_replace_all(" ", "_") |> 
    str_to_lower()
  
  # Rename 
  setnames(
    dt_use,
    old     = c(indicator), 
    new     = c("Indicator")
  )
  
  
  # Filter by year and country name
  dt_use <- dt_use[        # window length
    year %chin% c( (year_selected - window_length):
                     (year_selected + window_length))
  ]
  dt_use <- dt_use[
    country_name %chin% countries_selected
  ]
  
  # Fill Missing ----
  dt_use <- joyn::joyn(
    CJ(
      country_name = dt_use$country_name |> unique(), 
      year         = dt_use$year         |> unique()
    ),
    dt_use, 
    by = c("country_name", "year"), 
    reportvar = FALSE
  )
  dt_use[, missing := ifelse(is.na(Indicator), TRUE, FALSE)] # missing indicator
  #dt_use <- dt_use[, report := NULL]
  
  # If missing, impute forward or backwards
  setorder(dt_use, country_name, year) # order by year
  dt_forward  <- 
    dt_use[,
           .SD[c((window_length + 1):.N)], 
           by = country_name
           ][
             missing == FALSE
             ][, 
               .(Forward = min(year)-year_selected), 
               by = country_name
               ]
dt_backward <- 
  dt_use[, 
         .SD[c(1:(window_length + 1))], 
         by = country_name
         ][
           missing == FALSE
           ][, 
             .(Backward = abs(max(year)-year_selected)), 
             by = country_name
             ]

dt_use <- joyn::joyn(
    dt_use, 
    dt_forward, 
    by = c("country_name"), 
    yvars = T, 
    match_type = "m:1", 
    keep = "left", 
    reportvar = FALSE
  )

  #dt_use <- dt_use[, report := NULL]
  dt_use <- joyn::joyn(
    dt_use, 
    dt_backward, 
    by = c("country_name"), 
    yvars = T, 
    match_type = "m:1", 
    keep = "left", 
  reportvar = FALSE
  )
  #dt_use <- dt_use[, report := NULL]
  dt_use[is.na(Forward), Forward := 100]
  dt_use[is.na(Backward), Backward := 100]
  dt_use[, Impute_Forward := (Backward >= Forward)]
  
  # Do imputation
  dt_use[, 
         Indicator := {
    # Forward fill for Impute_Forward == FALSE
    Indicator[Impute_Forward == FALSE] <- 
      nafill(Indicator[Impute_Forward == FALSE], 
             type = "locf")
    # Backward fill for Impute_Forward == TRUE
    Indicator[Impute_Forward == TRUE] <- 
      nafill(Indicator[Impute_Forward == TRUE], 
             type = "nocb")
    # Return the modified Indicator
    Indicator
  }, by = country_name]
  
   # Do imputation of comparable spells
  dt_use[, 
         survey_comparability := {
    # Forward fill for Impute_Forward == FALSE
    survey_comparability[Impute_Forward == FALSE] <- na.locf(
      survey_comparability[Impute_Forward == FALSE])
    # Backward fill for Impute_Forward == TRUE
    survey_comparability[Impute_Forward == TRUE] <- na.locf(
      survey_comparability[Impute_Forward == TRUE], 
             fromLast=TRUE)
    # Return the modified Indicator
    survey_comparability
  }, by = country_name]
  
  # Years over which change occurs
  dt_use[
    , 
  ImputeYears:= min(Forward, Backward), 
  by = country_name
  ]
 dt_use[
   ImputeYears == 100, 
   ImputeYears := 0
 ]
  
  # Keep only selected year
  dt_use <- dt_use[ year == year_selected]
  # Remove columns
  dt_use[, c("Forward", "Backward") := NULL]
  
  setnames(
    dt_use, 
    old = "Indicator", 
    new = tolower(indicator)
  )
  
  # Return
  return(dt_use)
  
}



create_data_imputed_by_countries_two_years <- function(
    dt = dt_pip, 
    countries_selected  = c("South Africa", "Colombia", "United States"), 
    year1_selected      = 1998, 
    year2_selected      = 2005,
    indicator           = c("Gini"), 
    window_length       = 2 
){
  dt_use <- copy(dt)
  dt_use <- dt_use[, MeanWelfare := mean]
  # Data in Year 1
  dt1 <- create_data_imputed_by_countries(
    dt                 = dt_use, 
    countries_selected = countries_selected, 
    year_selected      = year1_selected, 
    indicator          = indicator, 
    window_length      = window_length
  )
  indicator <- indicator |> str_replace_all(" ", "_") |> str_to_lower()
  
  setnames(
    dt1, 
    old = c(tolower(indicator), "ImputeYears", "Impute_Forward"), 
    new = c("Indicator1", "ImputeYears1", "Impute_Forward1")
  )
  dt1 <- dt1[, .(country_name, year, Indicator1, MeanWelfare, ImputeYears1, Impute_Forward1, survey_comparability)]

  # Data in Year 2
  dt2 <- create_data_imputed_by_countries(
    dt                 = dt_use, 
    countries_selected = countries_selected, 
    year_selected      = year2_selected, 
    indicator          = indicator, 
    window_length      = window_length
  )
  setnames(
    dt2, 
    old = c(tolower(indicator), "ImputeYears", "Impute_Forward"), 
    new = c("Indicator2", "ImputeYears2", "Impute_Forward2")
  )
  dt2 <- dt2[, .(country_name, year, Indicator2, ImputeYears2, Impute_Forward2, region_name, survey_comparability)]
  
  # Join the two years
  dt_use <- joyn::joyn(
    dt1, 
    dt2, 
    keep = "inner", 
    match_type = "1:1", 
    by = c("country_name", "survey_comparability"), 
  reportvar = FALSE
  )
  
  # Find the change in indicator
  #dt_use[, report:=NULL]
  dt_use[, Change := Indicator2-Indicator1]
  dt_use[, ChangeColor := ifelse(Change>0, "Increase", "Decrease")]
  dt_use[
    Impute_Forward1 == TRUE & Impute_Forward2 == TRUE, # both forward imputed, or not imputed at all
    ChangeYears := {
      year2_selected - year1_selected - ImputeYears1 + ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == FALSE & Impute_Forward2 == TRUE, # both forward imputed, or not imputed at all
    ChangeYears := {
      year2_selected - year1_selected + ImputeYears1 + ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == TRUE & Impute_Forward2 == FALSE, # both forward imputed, or not imputed at all
    ChangeYears := {
      year2_selected - year1_selected - ImputeYears1 - ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == FALSE & Impute_Forward2 == FALSE, # both forward imputed, or not imputed at all
    ChangeYears := {
      year2_selected - year1_selected + ImputeYears1 - ImputeYears2
    }
  ]
  dt_use[, AnnualizedChange := Change/ChangeYears]
  dt_use[, Change := abs(Change)]
  dt_use[, country_name := factor(country_name, levels = country_name[order(Indicator1)])]
  
  #dt_use <- na.omit(dt_use)
  
  # Define tooltip
  dt_use[
    , 
    text_tooltip := 
      paste0(
        "Economy: ", country_name, "\n",
        "Region: ", region_name, "\n", 
        "Initial Value: ", round(Indicator1, 2), "\n", 
        "Annualized Change: ", round(AnnualizedChange, 2)
        
      )
  ]
  
  # Return
  return(dt_use)
  
}



```


Trends {#tab_trends}
===========================================================



Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-3}
# Select Indicator
selectInput("ineq_indicatorY_3_fig1", 
            label = "Indicator on y-axis of Figure 1",
            choices = c(
              "Mean", 
              "Median", 
              "MLD", 
              "Gini", 
              "Decile1",
              "Decile2",
              "Decile3",
              "Decile4",
              "Decile5",
              "Decile6",
              "Decile7",
              "Decile8",
              "Decile9",
              "Decile10",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Mean")

# Select Indicator
selectInput("ineq_indicatorY_3_fig2", 
            label = "Indicator on y-axis of Figure 2",
            choices = c(
              "Mean", 
              "Median", 
              "MLD", 
              "Gini", 
              "Decile1",
              "Decile2",
              "Decile3",
              "Decile4",
              "Decile5",
              "Decile6",
              "Decile7",
              "Decile8",
              "Decile9",
              "Decile10",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")

checkboxInput("log_y_3_fig1", 
              label = "Log Y axis in Figure 1",  
              value = FALSE)

checkboxInput("log_y_3_fig2", 
              label = "Log Y axis in Figure 2",  
              value = FALSE)

# Select region for scatter plot to highlight
selectInput("countries_selected_3",
            label    = "Select economies to plot",
            choices  = c(dt_pip$country_name |> unique() |> sort()),
            selected = c("Colombia", "Ghana", "Thailand"),
            multiple = TRUE)


radioButtons("all_years_plot", 
                   label = "Select years to plot",  
                   choices = c(
                     "All", 
                     "Custom"
                   ), 
                   selected = c("All"))


conditionalPanel(
  condition = "input.all_years_plot == 'Custom'",
  selectInput("select_initial_year_plot", 
              label = "Initial Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_plot == 'Custom'",
  selectInput("select_final_year_plot", 
              label = "Final Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_plot, 
             {
               updated_choices <- dt_pip[
                 year > as.numeric(input$select_initial_year_plot), 
                 unique(year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_plot", 
                 choices = updated_choices, 
                 selected = dt_pip$year |> max() 
               )
})


downloadButtonRmd(
  outputId = "DownloadButtonTrends2", 
  label = "CSV"
)

```



```{r data-filter3}

dt_trend_plot1 <- reactive({
  
  # Copy data table
  dt_trend_plot1 <- copy(dt_pip)
  
  if(input$all_years_plot == "Custom"){
    
    dt_trend_plot1 <- dt_trend_plot1[
      year >= input$select_initial_year_plot & 
        year <= input$select_final_year_plot, 
    ]
    
    
  }
  
  # rename
  ineq_indicators <- input$ineq_indicatorY_3_fig1 |> 
    tolower() |> 
    str_replace_all(
      pattern = " ", 
      replacement = "_"
    )
  
  # Filter for selected countries
  dt_trend_plot1 <- dt_trend_plot1[
     country_name %chin% input$countries_selected_3
  ]
  
  # Rename
  setnames(
    dt_trend_plot1, 
    old = ineq_indicators, 
    new = "IndicatorY"
  )
  
  dt_trend_plot1
  
  
  
})


dt_trend_plot2 <- reactive({
  
  # Copy data table
  dt_trend_plot2 <- copy(dt_pip)
  if(input$all_years_plot == "Custom"){
    
    dt_trend_plot2 <- dt_trend_plot2[
      year >= input$select_initial_year_plot & 
        year <= input$select_final_year_plot, 
    ]
    
    
  }
   # rename
  ineq_indicators <- input$ineq_indicatorY_3_fig2 |> 
    tolower() |> 
    str_replace_all(
      pattern = " ", 
      replacement = "_"
    )
  
  # Filter for selected countries
  dt_trend_plot2 <- dt_trend_plot2[
     country_name %chin% input$countries_selected_3
  ]
  
  # Rename
  setnames(
    dt_trend_plot2, 
    old = ineq_indicators, 
    new = "IndicatorY"
  )
  
  dt_trend_plot2

  
  
})

```


Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 

```{r plot3}

renderPlotly({
  
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot1()

# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorY) - min(IndicatorY)), by = country_name]
first_points = dt[, .SD[which.min(year)], by = country_name]
first_points = first_points[dt, on = .(country_name), nomatch = 0]

#Create tooltip variable
dt[
  ,
  text_tooltip := (
    paste0(
      "Economy: "                        , country_name, "\n",
      "Year: "                        , year,
      "\n", input$ineq_indicatorY_3_fig1, ": " , round(IndicatorY, 2)
    )
  )
]

# Initialize ggplot object
tp1 <- ggplot(dt) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig1 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_line(aes(x = round(year), y = transformation(IndicatorY), color = country_name, group = comparable_spell), alpha = 0.8)  + 
  geom_point(aes(x = round(year), y = transformation(IndicatorY), color = country_name, text = text_tooltip), size = 2, alpha = 0.9) +
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))+
  scale_color_brewer(palette = "Dark2")

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points, 
            aes(x = year, y = transformation(IndicatorY - rel_nudge_y), label = country_name, color = country_name),
            size = 2.5)

if(input$log_y_3_fig1 == TRUE){
  tp1 <- tp1 +
  scale_y_log10(labels = function(x) round(exp(x), 0))
}

dt_trend_plotly <- ggplotly(tp1, tooltip = "text")



dt_trend_plotly <- dt_trend_plotly |> 
   layout(
     images = list(
       list(
         source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
             xref = "paper",
            yref = "paper",
            x= 0.8,
            y= -0.075,
            sizex = 0.15,
            sizey = 0.15,
            opacity = 0.8
       )), 
       annotations = 
                 list(
                   x = 0, 
                   y = -0.1, 
                   text = source_text, 
                   showarrow = F, 
                   xref='paper', 
                   yref='paper', 
                   font=list(size=6, color="grey")
                   ))

dt_trend_plotly <- layout(dt_trend_plotly, 
            title = list(
              text = paste("Figure 1:", input$ineq_indicatorY_3_fig1, "over time"),
              titlefont = list(
                size = 14
              )
              ),
            titlefont = list(
              color = 'black', 
              size  = 14
            ),
            xaxis = list(
              title = ""
            ),
            yaxis = list(
              title = title_function(input$ineq_indicatorY_3_fig1), 
              titlefont = list(size  = 12)
            )
)

# Remove some modebar icons from plotly object
dt_trend_plotly <- dt_trend_plotly |> 
   config(
     modeBarButtonsToRemove = list(
       "lasso2d", 
       "zoom2d", 
       "pan2d", 
       "select2d",
       "zoomIn2d", 
       "zoomOut2d", 
       "autoScale2d", 
       "resetScale2d", 
       "hoverCompareCartesian", 
       "hoverClosestCartesian"
     )
   ) |>
  config(
    displaylogo = FALSE
  )
   #config(displayModeBar = F)

dt_trend_plotly

})

  


```


Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 

```{r plot3-2}

renderPlotly({
  
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot2()

# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorY) - min(IndicatorY)), by = country_name]
first_points = dt[, .SD[which.min(year)], by = country_name]
first_points = first_points[dt, on = .(country_name), nomatch = 0]
# Create tooltip variable
dt[
  , 
  text_tooltip := (
    paste0(
      "Economy: "                        , country_name, "\n",
      "Year: "                           , year, 
      "\n", input$ineq_indicatorY_3_fig2 , ": " , round(IndicatorY, 2)
    )
  )
]

# Initialize ggplot object
tp1 <- ggplot(dt) +
  # labs(
  #   title = paste("Figure 2:", input$ineq_indicatorY_3_fig2, "over time"), 
  #   subtitle = "Selected Economies", 
  #   x = "", 
  #   y = title_function(input$ineq_indicatorY_3_fig2)
  # ) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig2 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_line(aes(x = year, y = transformation(IndicatorY), color = country_name, group = comparable_spell), alpha = 0.8)  + 
  geom_point(aes(x = year, y = transformation(IndicatorY), color = country_name, text = text_tooltip), size = 2, alpha = 0.9) +
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))+
  scale_color_brewer(palette = "Dark2")

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points, 
            aes(x = year, y = transformation(IndicatorY - rel_nudge_y), label = country_name, color = country_name),
            size = 2.5)

if(input$log_y_3_fig2 == TRUE){
  tp1 <- tp1 +
  scale_y_log10(labels = function(x) round(exp(x), 0))
}

dt_trend_plotly <- ggplotly(tp1, tooltip = "text")

dt_trend_plotly <- dt_trend_plotly |> 
   layout(
     images = list(
       list(
         source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
             xref = "paper",
            yref = "paper",
            x= 0.8,
            y= -0.075,
            sizex = 0.15,
            sizey = 0.15,
            opacity = 0.8
       )), 
       annotations = 
                 list(
                   x = 0, 
                   y = -0.1, 
                   text = source_text, 
                   showarrow = F, 
                   xref='paper', 
                   yref='paper', 
                   font=list(size=6, color="grey")
                   ))

dt_trend_plotly <- layout(dt_trend_plotly, 
            title = list(
              text = paste("Figure 2:", input$ineq_indicatorY_3_fig2, "over time"),
              titlefont = list(
                size = 14
              )
              ),
            titlefont = list(
              color = 'black', 
              size  = 14
            ),
            xaxis = list(
              title = ""
            ),
            yaxis = list(
              title = title_function(input$ineq_indicatorY_3_fig2), 
              titlefont = list(size  = 12)
            )
)

dt_trend_plotly <- dt_trend_plotly |> 
   config(
     modeBarButtonsToRemove = list(
       "lasso2d", 
       "zoom2d", 
       "pan2d", 
       "select2d",
       "zoomIn2d", 
       "zoomOut2d", 
       "autoScale2d", 
       "resetScale2d", 
       "hoverCompareCartesian", 
       "hoverClosestCartesian"
     )
   ) |>
  config(
    displaylogo = FALSE
  )

dt_trend_plotly


})



reactive({
  

output$DownloadButtonTrends2 <- downloadHandler(
  filename = function() {
    paste("PIP-key-ineq-indicators-trends2", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(
      dt_trend_plot2()
      , file)
  }
)

})


```






Change over Time
===========================================================


Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-1}
# Select Indicator
selectInput("ineq_indicator", 
            label = "Indicator:",
            choices = c(
              "Mean", 
              "Median", 
              "MLD", 
              "Gini", 
              "Decile1",
              "Decile2",
              "Decile3",
              "Decile4",
              "Decile5",
              "Decile6",
              "Decile7",
              "Decile8",
              "Decile9",
              "Decile10",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")
# Select initial year
selectInput("initial_year",
            label    = "Initial Year",
            choices  = dt_pip$year |> unique() |> sort(),
            selected = 2010,
            multiple = FALSE)


# Select initial year
sliderInput("interval", 
             label = "Interval Length: measure the change over how many years?",
             min = 1, max = 10, value = 10, step = 1)

# Select initial year
sliderInput("window", 
             label = "Circa years window",
             min = 0, max = 5, value = 0, step = 1)

selectInput(
  "do_not_plot", 
  label    = "Remove from plot", 
  choices  = c(
    pip_countries_regions$region_name |> 
      sort() |> 
      unique(), 
    pip_countries |> 
      sort() |> 
      unique()
  ), 
  selected = NULL,
  multiple = TRUE
)


downloadButtonRmd(
  outputId = "DownloadButtonChange", 
  label = "csv"
)


```

Column {.tabset}
-----------------------------------------------------------------------

### Chart 


```{r data-filter-1}
dt_use <- reactive({
  
  # Filter countries ----
  deselected_countries <- c(
    pip_countries_regions[
      (country_name %chin% input$do_not_plot)
    ]$country_name, 
    pip_countries_regions[
      (region_name %chin% input$do_not_plot)
    ]$country_name
  ) |> 
    unique()
  
  dt_use <- dt_pip[
    !(country_name %chin% deselected_countries)
  ]
  
  dt_use <- create_data_imputed_by_countries_two_years(
    dt = dt_use, 
    countries_selected  = pip_countries, 
    year1_selected      = as.numeric(input$initial_year), 
    year2_selected      = c(as.numeric(input$initial_year) + as.numeric(input$interval)),
    indicator           = input$ineq_indicator, 
    window_length       = input$window 
)
  
})

```

```{r plot1}
renderPlotly({
dt1 <- dt_use()
dt1[
  , 
  MeanWelfare := round(MeanWelfare, 2)
]

# Initialize ggplot object
p <- ggplot(data = dt1) +
  theme_classic() +
  theme(legend.position = "none")

# Add segment layer with arrow
p <- p +
  geom_segment(
    aes(
      x     = Indicator1,
      xend  = Indicator2,
      y     = country_name,
      yend  = country_name,
      color = ChangeColor
    ), 
    arrow = arrow(length = unit(0.5, "inches"), type = "closed"), 
    alpha = 0.9
  )

# Add point layer first to avoid overlap
p <- p +
  geom_point(aes(x = Indicator1, y = country_name, colour = ChangeColor, text = text_tooltip), size = 2, 
    alpha = 0.9)



# Conditional logic for color scales
if(input$ineq_indicator %chin% c("Mean", "Median")){
  p <- p + 
    scale_color_manual(values = c("Increase" = "#1b9e77", "Decrease" = "#d95f02"))
} else{
  
  if(input$ineq_indicator %chin% c(paste0("Decile", 1:10))){
    p <- p + 
    scale_color_manual(values = c("Increase" = "#9ecae1", "Decrease" = "#3182bd"))
} else {
  p <- p + 
    scale_color_manual(values = c("Increase" = "#d95f02", "Decrease" = "#1b9e77"))
}
  
}



# Convert to plotly object
pp <- ggplotly(p, tooltip = "text")

pp <- pp |> 
   layout(
     images = list(
       list(
         source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
             xref = "paper",
            yref = "paper",
            x= 0.8,
            y= -0.05,
            sizex = 0.15,
            sizey = 0.15,
            opacity = 0.8
       )), 
       annotations = 
                 list(
                   x = 0, 
                   y = -0.1, 
                   text = source_text, 
                   showarrow = F, 
                   xref='paper', 
                   yref='paper', 
                   font=list(size=6, color="grey")
                   ))

pp <- layout(pp, 
            title = list(
              text = paste(
                "Change in", 
                input$ineq_indicator, 
                "from circa", 
                as.numeric(input$initial_year), 
                "to circa", 
                as.numeric(input$initial_year) + as.numeric(input$interval)
              )
            ),
            titlefont = list(
              color = 'black', 
              size  = 14
            ),
            xaxis = list(
              title = title_function(input$ineq_indicator), 
              titlefont = list(size = 12)
            ),
            yaxis = list(
              title = ""
            )
)



# Display the plot
pp |> 
   config(
     modeBarButtonsToRemove = list(
       "lasso2d", 
       "zoom2d", 
       "pan2d", 
       "select2d",
       "zoomIn2d", 
       "zoomOut2d", 
       "autoScale2d", 
       "resetScale2d", 
       "hoverCompareCartesian", 
       "hoverClosestCartesian"
     )
   ) |>
  config(
    displaylogo = FALSE
  )

})

reactive({
  
dt <- dt_use()
dt <- dt[
  ,
  .(country_name, year, region_name, Indicator1, AnnualizedChange)
]
setnames(
  dt, 
  old = c("country_name", "year", "region_name", "Indicator1", "AnnualizedChange"), 
  new = c("Country", "Year", "Region", str_to_title(input$ineq_indicator), "Annualized_Change")
)
# setnames(
#   dt, 
#   old = c("IndicatorX", "IndicatorY"), 
#   new = c(input$ineq_indicatorX, input$ineq_indicatorY)
# )
output$DownloadButtonChange <- downloadHandler(
  filename = function() {
    paste("PIP-key-ineq-indicators-change", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(
      dt
      , file)
  }
)

})


```



<p style='text-align:justify;'></p>

### Explanation

<!-- go to the [definitions page](#definitions) -->
<!-- go to [Definitions](#Definitions) -->
<!-- go to [About](#About) -->
<!-- go to [both](#AboutDefinitions) -->
<!-- go to [both](#AboutDefs) -->



<p style="text-align: justify;">
    This plot shows the change in the selected indicator over time for economies where there is comparable survey data in the chosen period. The <strong style="color:black">dot</strong> gives the initial indicator value for that economy. The <strong style="color:black">horizontal line segment</strong> connects the initial and final year indicator values. The <strong style="color:black">color</strong> indicates whether an economy's outcomes improve over the chosen interval. When mean or median are selected, green means these welfare measures have increased over time. For the remaining indicators, an increase is shown in red, meaning that the inequality has worsened. The economies on the y-axis are ordered according to the chosen indicator, where the top country has the largest indicator value in the initial year.
</p>

<strong style="color:black; text-align: justify;">What if an economy has no surveys in the chosen years?</strong>

<p style="text-align: justify;">
    Users specify the initial year (e.g., 2000) and the period over which they would like to study the change (e.g., the interval length is 5 years for looking at the 2000-2005 period).
</p>

<p style="text-align: justify;">
    Data might be missing for some economies for specific years. To increase the number of economies available, users can specify a circa year window. For example, if the chosen circa window is 2, then data 2 years either side of 2000 are considered (i.e., between 1998 and 2002). Within the circa window, data points in the initial and final years are selected with a preference for closer and newer data points: For example, if data for 2000 is missing, the algorithm will first look for data in 2001 and if 2001 data is also missing, it will then search in 1999. If both are missing, it will look for data in 2002 and 1998. An equivalent process is applied to the final year.
</p>

<p style="text-align: justify;">
    With a circa window larger than zero, the duration over which changes are measured differs across economies. For example, with an interval of 5 years and a window of 2, the duration varies between 1 year and 9 years (e.g. 2002-2003 and 1998-2007 are both permissible).
</p>



Scatterplot
===========================================================



Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-2}
# Select Indicator
selectInput("ineq_indicatorX", 
            label = "Indicator x-axis:",
            choices = c(
              "Mean", 
              "Median", 
              "MLD", 
              "Gini", 
              "Decile1",
              "Decile2",
              "Decile3",
              "Decile4",
              "Decile5",
              "Decile6",
              "Decile7",
              "Decile8",
              "Decile9",
              "Decile10",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Mean")
# Select Indicator
selectInput("ineq_indicatorY", 
            label = "Indicator y-axis:",
            choices = c(
              "Mean", 
              "Median", 
              "MLD", 
              "Gini", 
              "Decile1",
              "Decile2",
              "Decile3",
              "Decile4",
              "Decile5",
              "Decile6",
              "Decile7",
              "Decile8",
              "Decile9",
              "Decile10",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")


selectInput("select_welfare_type", 
              label = "Survey Type:", 
              choices = c("Both", "Consumption", "Income"), 
              selected = "Both"
)

checkboxGroupInput(
  inputId  = "log_transformations", 
  label    = "Log Transformations:", 
  choices  = c("Y axis", "X axis"), 
  selected = NULL
)



selectInput("countries_selected",
            label    = "Select economies",
            choices  = c(
              "All", 
              dt_pip$region_name |> 
                unique() |> 
                sort(), 
              pip_countries
            ),
            selected = "All",
            multiple = TRUE)
# Select region for scatter plot to highlight
selectInput("background_regions",
            label    = "Select comparison economies",
            choices  = c(
              "All", 
              dt_pip$region_name |> 
                unique()
            ),
            selected = "",
            multiple = TRUE)
radioButtons("color_by", 
                   label = "Color points by:",  
                   choices = c(
                     "Region", 
                     "Income group"
                   ), 
                   selected = c("Region"))

radioButtons("all_years_scatterplot", 
                   label = "Select years to plot",  
                   choices = c(
                     "All", 
                     "Custom"
                   ), 
                   selected = c("All"))

conditionalPanel(
  condition = "input.all_years_scatterplot == 'Custom'",
  selectInput("select_initial_year_scatterplot", 
              label = "Initial Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_scatterplot == 'Custom'",
  selectInput("select_final_year_scatterplot", 
              label = "Final Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_scatterplot, 
             {
               updated_choices <- dt_pip[
                 year > as.numeric(input$select_initial_year_scatterplot), 
                 unique(year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_scatterplot", 
                 choices = updated_choices, 
                 selected = dt_pip$year |> max() 
               )
})

```
Advanced Features:
```{r}
checkboxInput("add_line", 
              label = "Add fitted line", 
              value = FALSE)


downloadButtonRmd(
  outputId = "DownloadButtonScatterplot", 
  label = "CSV"
)

```


Column {.tabset}
-----------------------------------------------------------------------

```{r data-filter2}



selected_countries <- reactive({
    
  # get list of selected countries
  if(c("All") %chin% input$countries_selected){
    
    selected_countries <- dt_pip$country_name |> unique()
    
  } else {
    
    selected_countries <- c(
    (pip_countries_regions[country_name %chin% input$countries_selected])$country_name, 
    (pip_countries_regions[region_name %chin% input$countries_selected])$country_name
  ) |> unique()
    
  }
  
  
    # welfare
  if(!input$select_welfare_type == c("Both")){
    selected_countries <- intersect(
      selected_countries, 
      dt_pip[welfare_type == tolower(input$select_welfare_type)]$country_name
    ) |> unique()
  }else {
    selected_countries
  }
  selected_countries
  
})


dt_use_sp <- reactive({
  
  # Copy pip stats
  dt_use_sp <- copy(dt_pip)
  
  # filter years
  if(input$all_years_scatterplot == "Custom"){
    
    dt_use_sp <- dt_use_sp[
      year >= input$select_initial_year_scatterplot & 
        year <= input$select_final_year_scatterplot
    ]
    
  }
  
  # Filter by survey type
  if(!input$select_welfare_type =="Both"){
    dt_use_sp <- dt_use_sp[
      welfare_type == tolower(input$select_welfare_type)
    ]
  } else{
    dt_use_sp
  }
  
  
  # Keep selected and background countries
  if(
    ! any(
      c(
        "All" %chin% input$countries_selected, 
        "All" %chin% input$background_regions
      )
    )
  ){
    
    # which countries to keep in data
    countries_filtered <- c(
      selected_countries(), 
      pip_countries_regions[
        region_name %chin% input$background_regions
      ]$country_name
    )
    
    # filter
    dt_use_sp <- dt_use_sp[
      country_name %chin% countries_filtered
    ]
    
    
  }
  
  # Change names of selected indicators
  
  ineq_indic_X <- input$ineq_indicatorX |> str_replace_all(" ", "_") |> str_to_lower()
  ineq_indic_Y <- input$ineq_indicatorY |> str_replace_all(" ", "_") |> str_to_lower()
  
  setnames(
    x = dt_use_sp, 
    old = c(ineq_indic_X, ineq_indic_Y), 
    new = c("IndicatorX", "IndicatorY")
  )
  
  dt_use_sp[
    , 
    Region := region_code
  ]
  dt_use_sp[
    , 
    `Income Group` := incgroup_current
  ]
  # factor(incgroup_current, levels = incgroup_current[order(mean)])]
  # Define tooltip
  dt_use_sp[
    , 
    text_tooltip := (
      paste0(
        "Economy: ", country_name, "\n",
        "Region: ", region_name,  "\n",
        "Income Group: ", incgroup_current, "\n",
        input$ineq_indicatorX, ": ", round(IndicatorX,2),  "\n",
        input$ineq_indicatorY, ": ", round(IndicatorY, 2),  "\n",
        "Survey type: ", str_to_title(welfare_type)
      )
    )
  ]
col_vec <- c()
all_cntr <- dt_use_sp$country_name 
reg <- dt_use_sp$region_name
inc <- dt_use_sp$incgroup_current
dt <- data.table(all_cntr = all_cntr, reg = reg)
# Conditionally define 'bla' based on the value of 'Check'
if (input$color_by == "Region") {
  dt[, col_vec := ifelse(all_cntr %chin% selected_countries(), reg, "Unselected")]
} else if (input$color_by == "Income group") {
  dt[, col_vec := ifelse(all_cntr %chin% selected_countries(), inc, "Unselected")]
}
# Extract the 'bla' column to a vector
col_vec <- dt$col_vec


# dt_use_sp <- dt_use_sp |> 
#   mutate(
#     Color = ifelse(
#       country_name %chin% selected_countries(), 
#       ifelse(
#         input$color_by == "Region", dt_use_sp$region_name, dt_use_sp$incgroup_current
#       ), 
#       "Other"
#     )
#   )
    
dt_use_sp[, Color := col_vec]


    })


```

### Chart

```{r plot2}

renderPlotly({


transformation_x <- function(x){
  
  if("X axis" %chin% input$log_transformations){
    log(x)
  } else{
    x
  }
  
}

transformation_y <- function(x){
  
  if("Y axis" %chin% input$log_transformations){
    log(x)
  } else{
    x
  }
}
# define tooltip ----
dt <- dt_use_sp()
# Initialize ggplot object
sp1 <- ggplot(dt, aes(color = Color))

# Custom function to modify the palette
modify_palette <- function(palette_name, name_to_change, new_color) {
  palette <- brewer.pal(name = palette_name, n = length(unique(dt$Color)))
  names(palette) <- unique(dt$Color)
  palette[name_to_change] <- new_color
  return(palette)
}
# Modify the Dark2 palette to have "NOT" as light grey
modified_palette <- modify_palette("Dark2", "Unselected", "lightgrey")

sp1 <- sp1 +
  scale_color_manual(values = modified_palette, drop = TRUE)

  # scale_color_brewer(palette = "Dark2")

# # Add geom_point
# if(input$color_by == "Region"){
# Dynamically generate alpha values
unique_colors <- unique(dt$Color)
alpha_values <- setNames(rep(0.9, length(unique_colors)), unique_colors)
alpha_values["Unselected"] = 0.2

  sp1 <- sp1 +
  geom_point(aes(
    x = transformation_x(IndicatorX),
    y = transformation_y(IndicatorY),
    color = Color,
    text = text_tooltip, 
    alpha = Color
  ), alpha = 0.55) +
  scale_alpha_manual(values = alpha_values) +
  guides(alpha=FALSE, color=guide_legend(override.aes=list(alpha=1)))



# Add geom_smooth if required
if (input$add_line == TRUE) {
  sp1 <- sp1 +
    geom_smooth(
      aes(
        x = transformation_x(IndicatorX),
        y = transformation_y(IndicatorY),
        stat = "smooth",
        position = "identity"
      )
    )
}

# Adjust theme
sp1 <- sp1 + theme_classic()
#   
# if log transform, use original units
  if(c("X axis" %chin% input$log_transformations)){
    
      if(input$ineq_indicatorX == "Mean"){
        sp1 <- sp1 + 
          scale_x_log10(
            labels = function(x) round(exp(x), 0), 
            limits = c(log(1.1), log(94))
          )
      } else{
        sp1 <- sp1 + 
          scale_x_log10(
            labels = function(x) round(exp(x), 0)
          )
      }
  
  }
  if(c("Y axis" %chin% input$log_transformations)){
    
      if(input$ineq_indicatorY == "Mean"){
        sp1 <- sp1 + 
          scale_y_log10(
            labels = function(x) round(exp(x), 0), 
            limits = c(log(1.1), log(94))
          )
      } else{
        sp1 <- sp1 + 
          scale_y_log10(
            labels = function(x) round(exp(x), 0)
          )
      }
  
  }




# Convert to plotly object
sp1_plotly <- ggplotly(sp1, tooltip = "text")



# Display the plot
sp1_plotly <- sp1_plotly |>
   layout(
     images = list(
       list(
         source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
             xref = "paper",
            yref = "paper",
            x= 0.8,
            y= -0.05,
            sizex = 0.15,
            sizey = 0.15,
            opacity = 0.8
       )),
       annotations =
                 list(
                   x = 0,
                   y = -0.08,
                   text = source_text,
                   showarrow = F,
                   xref='paper',
                   yref='paper',
                   font=list(size=6, color="grey")
                 ))


sp1_plotly <- layout(sp1_plotly, 
            title = list(text = paste("Relationship between", input$ineq_indicatorX, "and", input$ineq_indicatorY)),
            titlefont = list(size = 14),
            xaxis = list(title = title_function(input$ineq_indicatorX), titlefont = list(size = 12)),
            yaxis = list(
              title = title_function(input$ineq_indicatorY),
              titlefont = list(size = 12)  
            )
)


sp1_plotly |> 
   config(
     modeBarButtonsToRemove = list(
       "lasso2d", 
       "zoom2d", 
       "pan2d", 
       "select2d",
       "zoomIn2d", 
       "zoomOut2d", 
       "autoScale2d", 
       "resetScale2d", 
       "hoverCompareCartesian", 
       "hoverClosestCartesian"
     )
   ) |>
  config(
    displaylogo = FALSE
  )


})


reactive({
  
dt <- dt_use_sp()
dt <- dt[
  , 
  .(country_name, region_name, IndicatorX, IndicatorY)
]
setnames(
  dt, 
  old = c("IndicatorX", "IndicatorY"), 
  new = c(input$ineq_indicatorX, input$ineq_indicatorY)
)
output$DownloadButtonScatterplot <- downloadHandler(
  filename = function() {
    paste("PIP-key-ineq-indicators-scatterplot", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(
      dt
      , file)
  }
)

})


```



### Explanation



<p style='text-align:justify;'>This scatterplot shows the relationship between two selected indicators. By default, it shows all data, regardless of economy, region, or whether welfare is measured by consumption or income. Making selections on the side panel will limit the display to the selected data (e.g. selecting SSA as the region and consumption as the welfare measure plots data for Sub-Saharan Africa where welfare is measured by consumption). The selected data can be compared against other economies or regions. Dots are colored by region. The chart sorts countries by PIPâ€™s regional definition: East Asia and Pacific  (EAP), Europe and Central Asia (ECA), Latin America and the Caribbean (LAC), Middle East and North Africa (MNA), Other High Income (OHI), South Asia (SAS), Sub-Saharan Africa (SSA)</p>

<p style='text-align:justify;'>The plot provides a feature for incorporating a line to depict the underlying relationship between variables. This line represents the conditional mean, estimated via locally estimated scatterplot smoothing (LOESS), and is accompanied by 95% confidence intervals.</p>





High inequality
===========================================================


Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-ineq}
# Select Plot
selectInput("high_ineq_plot",
            label = "Show ineq. groups:",
            choices = c(
              "Over time",
              "By selected group", 
              "Across countries"
            ),
            selected = "Over time")

# Select Indicator
conditionalPanel(
  condition = "input.high_ineq_plot == 'Over time'",
  selectInput("high_ineq_region",
              label = "Plot by:",
              choices = c(
                "Global",
                dt_ineq$region_code |>
                  unique()
              ),
              selected = "Global", 
              multiple = FALSE))

# Select Indicator
conditionalPanel(
  condition = "input.high_ineq_plot == 'By selected group' ",
  selectInput("high_ineq_group_by",
              label = "Plot by:",
              choices = c(
                "Income groups",
                "Regions", 
                "FCV", 
                "IDA"
              ),
              selected = "Income groups", 
              multiple = FALSE))

# conditionalPanel(
#   condition = "input.all_years_scatterplot == 'Custom'",
#   selectInput("select_initial_year_scatterplot", 
#               label = "Initial Year:",
#               choices = dt_pip$year |> 
#                 unique() |> 
#                 sort(),
#               selected = dt_pip$year |> 
#                 min(), 
#               multiple = FALSE)
# )


```

Column {.tabset}
-----------------------------------------------------------------------

### Chart 


```{r}
# 
# high_ineq_counts_plot <- reactive({
#   
#   p <- dt_ineq |> 
#     fmutate(ineq_type = factor(ineq_type, 
#                                level = c("High inequality (>40)", 
#                                          "Moderate inequality (30-40)",
#                                          "Low inequality (<30)"))) |> 
#     fgroup_by(ineq_type, year) |> 
#     fselect(ineq_type, year, country_count) |> 
#     fnobs() |> 
#     fungroup() |> 
#     fmutate(text_tooltip = paste0("Year: ", year, "\n",
#                                   "Count: ", country_count, "\n", 
#                                   "Ineq. type: ", ineq_type))
#   
#   # if (!input$high_ineq_region == "Global") {
#   #   p <- p |> 
#   #     fsubset(region_code == !input$high_ineq_region)
#   # }
# 
#     ggplot(aes(x     = year,
#                y     = country_count, 
#                fill  = ineq_type, 
#                color = ineq_type, 
#                text  = text_tooltip)) +
#     geom_col(position = position_fill(), alpha = 0.8) +
#     scale_y_continuous(labels = scales::percent) +
#     geom_text(aes(label = country_count),
#             position  = position_fill(vjust = .5), 
#             color = "black") + 
#     theme_classic() +  
#     labs(title = paste0("Number of countries in each inequality category, ", input$high_ineq_region),
#          x = "Year",
#          y = "Economy count",  
#          linetype = "Cylinder") +
#     guides(color = "none") + 
#     guides(fill = guide_legend(title = "Inequality type"))
#   
#     ggplotly(p, 
#              tooltip = "text")
#   
# })

```

```{r}

renderPlotly({
  
  if (input$high_ineq_plot == "Over time") {
      if (!input$high_ineq_region == "Global") {
        p <- dt_ineq |>
          fsubset(region_code == as.character(input$high_ineq_region))
      } else {
        p <- dt_ineq
      }
        p <- p |> 
        fmutate(ineq_type = factor(ineq_type, 
                                   level = c("High inequality (>40)", 
                                             "Moderate inequality (30-40)",
                                             "Low inequality (<30)"))) |> 
        fgroup_by(ineq_type, year) |> 
        fselect(ineq_type, year, country_count) |> 
        fnobs() |> 
        fungroup() |> 
        fmutate(text_tooltip = paste0("Year: ", year, "\n",
                                      "Count: ", country_count, "\n", 
                                      "Ineq. type: ", ineq_type))
      
        p <- p |> 
        ggplot(aes(x     = year,
                   y     = country_count, 
                   fill  = ineq_type, 
                   color = ineq_type, 
                   text  = text_tooltip)) +
        geom_col(position = position_fill(), alpha = 0.8) +
        scale_y_continuous(labels = scales::percent) +
        geom_text(aes(label = country_count),
                position  = position_fill(vjust = .5), 
                color = "black") + 
        theme_classic() +  
        labs(title = paste0("Number of countries in each inequality category, ", input$high_ineq_region),
             x = "Year",
             y = "Economy count",  
             linetype = "Cylinder") +
        guides(color = "none") + 
        guides(fill = guide_legend(title = "Inequality type"))
      
        ggplotly(p, 
                 tooltip = "text")
  } else if (input$high_ineq_plot == "By selected group") {
          gb <- switch(input$high_ineq_group_by, 
               "Income groups" = "incgroup_current", 
               "Regions"       = "region_code", 
               "FCV"           = "fcv_current", 
               "IDA"           = "ida_current", 
               input$high_ineq_group_by)
  
  max_year <- max(dt_ineq$year)
  
  p <- dt_ineq |> 
    fsubset(year == max_year) |> 
    fmutate(ineq_type = factor(ineq_type, 
                               level = c("High inequality (>40)", 
                                         "Moderate inequality (30-40)",
                                         "Low inequality (<30)")))
  setnames(x   = p, 
           old = c(as.character(gb)), 
           new = "Group")
  
  p <- p |> 
    fselect(ineq_type, year, Group, country_count) |>
    fgroup_by(ineq_type, year, Group) |>
    fnobs() |>
    fungroup()
    
  p <- p |> 
    fgroup_by(Group) |> 
    fmutate(use          = country_count/sum(country_count), 
            text_tooltip = paste0("Year: ", year, "\n",
                                  "Share: ", round(use, 2), "\n", 
                                  "Ineq. type: ", ineq_type, "\n", 
                                  input$high_ineq_group_by, ": ", Group))
  
  p <- p |>
    ggplot(aes(x     = Group,
               y     = use,
               fill  = ineq_type, 
               color = ineq_type, 
               text  = text_tooltip)) +
    geom_bar(stat     = 'identity',
             position = 'stack', 
             alpha    = 0.8) +
    theme_classic() +  
    labs(title = paste0("Share of economies in different inequality categories, by ", tolower(input$high_ineq_group_by)),
         x = input$high_ineq_group_by,
         y = "Share of economies, %") +
    guides(color = "none") + 
    scale_y_continuous(labels = scales::percent) +
    guides(fill = guide_legend(title = "Inequality type"))
  
  ggplotly(p, 
           tooltip = "text")
      }

})



```

### Explanation
```{r}
# renderPlotly({
# 
# })


```


<p style='text-align:justify;'></p>



<!-- go to the [definitions page](#definitions) -->
<!-- go to [Definitions](#Definitions) -->
<!-- go to [About](#About) -->
<!-- go to [both](#AboutDefinitions) -->
<!-- go to [both](#AboutDefs) -->












Table
===========================================================


Sidebar {.sidebar data-width=150}
-----------------------------------------------------------------------

```{r sidebar-table-1}

# Select Indicator
checkboxGroupInput("ineq_indicator_table", 
            label = "Indicators:",
            choices = c(
              "Mean", 
              "Median", 
              "Gini",
              "MLD",
              "Decile Shares",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected =  c(
              "Mean", 
              "Gini",
              "Top 10 Bottom 40 Ratio"
            ))


selectInput("select_countries_table", 
            label = "Economies:",
            choices = c(
              "All", 
              dt_pip$region_name |> 
                unique() |> 
                sort(),  
              pip_countries
            ),
            selected = c("All"), 
            multiple = TRUE)



radioButtons("all_years_table", 
                   label = "Years shown in table",  
                   choices = c(
                     "Latest", 
                     "All", 
                     "Custom"
                   ), 
                   selected = c("Latest"))


conditionalPanel(
  condition = "input.all_years_table == 'Custom'",
  selectInput("select_initial_year_table", 
              label = "Initial Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_table == 'Custom' && input.select_initial_year_table != null",
  selectInput("select_final_year_table", 
              label = "Final Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_table, 
             {
               updated_choices <- dt_pip[
                 year > as.numeric(input$select_initial_year_table), 
                 unique(year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_table", 
                 choices = updated_choices, 
                 selected = dt_pip$year |> max() 
               )
})


# Render download button
#downloadButton("downloadData", "Download CSV")

downloadButtonRmd(
  outputId = "DownloadButtonTable", 
  label = "CSV"
)


```




Row {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 

```{r plot-table}


make_table_across_countries <- function(
    dt,
    country_name_vec = c("Angola", "South Africa"),
    ineq_indicators, 
    years_selected = c("All", "Latest", "Custom"), 
    start_year = NULL, 
    end_year = NULL
){
  dt <- copy(dt)
  # Check Inputs ----
  stopifnot(is.data.table(dt))
  stopifnot(country_name_vec %chin% pip_countries)
  years_selected <- match.arg(years_selected)

  # If decile shares is selected
  if(c("Decile Shares") %chin% ineq_indicators ){
    # remove "Decile Shares" element
    ineq_indicators <- ineq_indicators[!c("Decile Shares") == ineq_indicators]
    # add all individual decile shares
    ineq_indicators <- c(
      ineq_indicators, 
      paste0("decile", 1:10)
    )
  }
  
  # IF the ratios selected
  if(c("Top 10 Bottom 40 Ratio") %chin% ineq_indicators){
    # remove ratios elements
    ineq_indicators <- ineq_indicators[!c("Top 10 Bottom 40 Ratio") ==ineq_indicators]
    # add all individual decile shares
    ineq_indicators <- c(
      ineq_indicators, 
      "t10_b40"
    )
  }
    # IF the ratios selected
  if(c("Top 20 Bottom 20 Ratio") %chin% ineq_indicators){
    # remove ratios elements
    ineq_indicators <- ineq_indicators[!c("Top 20 Bottom 20 Ratio") == ineq_indicators]
    # add all individual decile shares
    ineq_indicators <- c(
      ineq_indicators, 
      "t20_b20"
    )
  }
  
  # Prepare Data ----
  selected_cols <- c(
    "Country",
    "Region",
    "Year",
    "Level",
    "Type",
    "Spell",
    ineq_indicators
  )
  selected_cols <- 
    selected_cols |> 
    str_replace_all(" ", "_") |> 
    str_to_lower() |> 
    str_to_title()
  
  setnames(
    dt,
    old = c("country_name", "region_code", "comparable_spell", "reporting_level", "welfare_type", "top_10_bottom_40_ratio", "top_20_bottom_20_ratio"),
    new = c("country", "region", "spell", "level", "type", "t10_b40", "t20_b20")                           # Clean variable names
  )
  setnames(
    dt,
    stringr::str_to_title(names(dt))             # Capitalize column names
  )
  
  
  dt <- dt[
    Country %chin% country_name_vec,         # filter by country
    ..selected_cols                             # Select id vars and inequality indicators
  ]
  
  dt[
    ,
    (names(dt)) := lapply(                       # Round to 2 decimals
      .SD,
      \(x){
        if (is.numeric(x)) 
          round(x, 2) 
        else 
          x
        }
    )
  ]
  
  
  # Filter years
  if(years_selected == "Latest"){
    dt <- dt[, 
             .SD[which.max(Year)], 
             by = Country]
  }
  if(years_selected == "Custom"){

    if(start_year > end_year)
      stop("Please note the initial year must be lower than the final year")
    dt <- dt[
      Year >= start_year &
        Year <= end_year
    ]

  }
  
  
  setorder(dt, Country, Region, -Year, Level, Type)
  
  # setnames(
  #   dt, 
  #   old = c("Type"), 
  #   new = c("Survey_type")
  # )
  if("Mld" %chin% names(dt)){
    setnames(
      dt, 
      old = "Mld", 
      new = "MLD"
    )
  }
  
  # remove comparable spell
  dt[
    , 
    Spell := NULL
  ]
  
  dt # return
} # end of make_table_across_countries()



table <-
  reactive({
    
    # Filter countries
    
    ct <- 
      if ("All" %chin% input$select_countries_table) {
      pip_countries
    } else {
      c(pip_countries_regions[country_name %chin%
                                input$select_countries_table]$country_name,
        pip_countries_regions[region_name %chin%
                                input$select_countries_table]$country_name
        ) |>
        unique()
    }
    
    make_table_across_countries(
      dt               = dt_pip,
      country_name_vec = ct,
      ineq_indicators  = input$ineq_indicator_table,
      years_selected   = input$all_years_table, 
      start_year       = input$select_initial_year_table, 
      end_year         = input$select_final_year_table
  )
})

  

renderPlotly({
  
list_of_columns <- lapply(
    names(table()), 
    \(col_name) { # Make the columns list items for plotly
      return(table()[[col_name]])
    })
  
  # plot table
  t <- plot_ly(
    type = 'table',
    #columnwidth = c(100, 100),
    header = list(
      values = table() |> 
        colnames() |> 
        # column names vector
        str_replace_all(pattern = "_", 
                        replacement = " "), 
      align = "center",
      line = list(width = 1, color = 'black'),
      fill = list(color = c("grey", "grey")),
      font = list(family = "Arial", size = 10, color = "white")
    ),
    cells = list(
      values = list_of_columns,
      align  = c("center", "center"),
      line   = list(color = "black", width = 1),
      font   = list(family = "Arial", size = 10, color = c("black"))
    ))
  
t <- layout(
  t,
  title   = "PIP Key Inequality Indicators, Selected Economies and Years",
  titlefont = list(color = 'black', size = 14), 
  title_x = 0 
)
  
 t <- t |> 
   layout(
     images = list(
       list(
         source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
             xref = "paper",
            yref = "paper",
            x= 0.8,
            y= -0.02,
            sizex = 0.15,
            sizey = 0.15,
            opacity = 0.8
       )), 
       annotations = 
                 list(
                   x = 0, 
                   y = -0.05, 
                   text = source_text, 
                   showarrow = F, 
                   xref='paper', 
                   yref='paper', 
                   font=list(size=8, color="grey")
                   ))
 t |>
  config(
    displaylogo = FALSE
  )
  
})


output$DownloadButtonTable <- downloadHandler(
  filename = function() {
    paste("PIP-key-ineq-indicators-table", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(table(), file)
  }
)



```








About {#tab_about}
===========================================================

Column {.tabset}
-----------------------------------------------------------------------

### About {#About}

<!-- {data-width=500} -->
<p style='text-align:justify;'>This dashboard provides a set of interactive visualizations focused on within-country inequality. The data are from the [Poverty and Inequality Platform (PIP)](https://pip.worldbank.org/home), which is the source of the World Bankâ€™s estimates of poverty and inequality. </p>

<p style='text-align:justify;'>The estimates are based on country-level household survey unit record data or grouped data. Survey data are the most widely available source of information on distributions of income or consumption. However, research on some countries has shown that surveys tend to underestimate the income of the richest, for which no corrections have been made in these estimates. </p>

<p style='text-align:justify;'>From the survey, a measure of household welfare is constructed, capturing either household income or consumption. There are important differences between the two concepts; in particular, inequality in incomes is systematically greater than inequality in consumption. Countries in Europe and Central Asia, Latin America and the Caribbean, the Other High Income group tend to use income surveys, while the rest of the world uses consumption. Users are advised to take these differences into account, especially when comparing levels of inequality across countries and regions.</p>

<p style='text-align:justify;'>There are a few special cases where a country has more than one survey in a single year. However, in this dashboard the data are limited to a maximum of one survey per country per year. To download the full PIP data set, including multiple surveys per country-year, go to the [Poverty & Inequality Indicators](https://pip.worldbank.org/poverty-calculator) and download all country data.</p>

<p style='text-align:justify;'>Changes in questionnaire design imply that estimates of poverty and inequality within countries become incomparable. Whenever such changes occur, a break is shown in the inequality trend. The visualization of changes over time only includes countries that have a [comparable](https://datanalytics.worldbank.org/PIP-Methodology/welfareaggregate.html#comparability) survey spell over the period chosen.</p>

<p style='text-align:justify;'>The term country, used interchangeably with economy, does not imply political independence but refers to any territory for which authorities report separate social or economic statistics.</p>

<p style='text-align:justify;'>For more details on the methodology, please visit the [PIP Methodology Handbook](https://datanalytics.worldbank.org/PIP-Methodology/) and the [Global Poverty Monitoring Technical Notes](https://pip.worldbank.org/publication). For any questions regarding the data or methodology, please contact pip@worldbank.org.</p>

<p style='text-align:justify;'>Please cite the data as:  World Bank. (2023). Poverty and Inequality Platform (version 20230919_2017) [Data set]. World Bank Group. www.pip.worldbank.org. Accessed `r today()`. </p>




### Definitions {#Definitions}

<span class="underline">Inequality indicators:</span>

\newline
<p style='text-align:justify;'>The **Gini** index ranges from 0 (perfect equality) to 100 (complete inequality). The **mean log deviation (MLD)** belongs to the family of generalized entropy inequality measures. The MLD has a minimum value of 0 (perfect equality) and has no upper bound. The Gini index is especially sensitive to changes around the middle of the distribution, while the MLD is more sensitive to changes at the bottom. The **decile shares** focus on particular parts of the distribution of income or consumption: Households are first ordered according to their welfare per capita, such that the first decile contains the 10% of the population with the lowest welfare and so on. Decile shares measure the share of total welfare belonging to each decile. The **top 10 to bottom 40 ratio** (also known as the Palma ratio) compares the welfare share of the richest tenth of the population to the poorest 40 percent. Similarly, the **top 20 to bottom 20 ratio** is the share of the richest quintile to the poorest quintile. More details on the definition of the indicators can be found [here](https://datanalytics.worldbank.org/PIP-Methodology/surveyestimates.html#inequality). </p>

<span class="underline">Other variables:</span>

\newline

<p style='text-align:justify;'>The **mean** refers to average daily household per capita income or consumption in 2017 PPP USD. Purchasing power parity (PPP) conversion factors are used to adjust for price differences across countries. Similarly, the **median** refers to the median daily household per capita income or consumption in 2017 PPP USD. 
The **year** variable is the starting year of the household survey. In some countries, the data collection spans multiple years. When looking at changes over time, users can select **circa years** (i.e., a window around the chosen year). This increases the sample of countries available, since not all countries have annual household surveys, as explained in more detail on the chart page.</p>

<p style='text-align:justify;'>Countries can also be grouped by **region**. The dashboard uses PIPâ€™s [regional definition](https://datanalytics.worldbank.org/PIP-Methodology/lineupestimates.html#regionsandcountries) which differs from the regional classifications used by the World Bank. Some high-income economies are excluded from the geographical regions and are included as a separate group referred to as â€œother high incomeâ€.</p>


