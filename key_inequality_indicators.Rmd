---
title: " PIP Key Inequality Indicators"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    social: menu
    theme: paper
    source_code: embed
    vertical_layout: fill
runtime: shiny
---

```{r setup-packages, include=FALSE}
library("here")
library("data.table")
library("ggplot2")
library("plotly")
library("flexdashboard")  
library("tidyverse")
library("pak")
library("rlang")
library("joyn")
library("gghighlight")
library("DT")
```

```{r setup-data, include=FALSE}
# Total pip output

# Step 1: data ----
dt_pip <- pipr::get_stats()  # install entire data
dt_pip <- data.table(dt_pip) # as data.table
dt_pip[
  , 
  `:=`(
    top_10_bottom_40_ratio = (decile10)/(decile1 + decile2 + decile3 + decile4), 
    top_20_bottom_20_ratio = (decile10+decile9)/(decile1 + decile2)
  )
]
dt_pip[, 
       gini:= gini*100]

# Step 2: creating general objects ----
pip_countries <- unique(dt_pip$country_name) # list of countries
pip_countries_multiple_welfare_type <- 
  dt_pip[, 
         if(.N>1) .SD, 
         by = .(country_name, year, welfare_type)
         ]$country_name |>
  unique()

pip_countries_multiple_reporting_level <- 
  dt_pip[, 
         if(.N > 1) 
           .SD, 
         by = .(country_name, year, reporting_level)
         ]$country_name |> 
  unique()

pip_countries_regions <- 
  unique(dt_pip, 
         by = c("country_name", "region_code")
         )[, 
           .(country_name, region_code, region_name)
           ]
region_matching <- unique(
  dt_pip[
    ,
    .(region_name), 
    by = region_code
  ]
)
# Exclude double rows
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[!reporting_level == "rural"] 
          } else {
            .SD
            }, 
         by = .(country_name, year, welfare_type)
         ][, 
           if (.N > 1) {
             .SD[reporting_level == "national"] 
             } else {
               .SD
               }, 
           by = .(country_name, year, welfare_type)
           ]
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[welfare_type == "income"] 
           } else {
             .SD
             }, 
         by = .(country_name, year, reporting_level)
         ]

```


```{r load-data-functions}

create_data_imputed_by_countries <- function(
    dt, 
    countries_selected  = c("South Africa", "Colombia", "United States"), 
    year_selected       = 1998, 
    indicator           = c("Gini"), 
    welfare             = NULL, # if 'consumption' or 'income' then use *only* those
    window_length       = 2 
    
){
  
  # Argument Checks ----
  stopifnot(is.data.table(dt))
  if(
    is.null(countries_selected) | 
    is.null(year)               | 
    is.null(indicator)          | 
    is.null(indicator)
  ) stop ( "Must choose" )
  if(
    length(year) > 1            | 
    length(indicator) > 1 
  ) stop ( "Can only select one year and one indicator" )
  
  # Use copy of dt
  dt_use <- copy( dt )
  
  indicator <- indicator |> str_replace_all(" ", "_") |> str_to_lower()
  
  # Rename 
  setnames(
    dt_use,
    old     = c(indicator), 
    new     = c("Indicator")
  )
  
  # Filter ----
  if( !is.null(welfare) ) { # welfare type
    
    dt_use <- dt_use[
      welfare %chin% welfare_type
    ]
    
  }
  
  # Filter by year and country name
  dt_use <- dt_use[        # window length
    year %chin% c( (year_selected - window_length):
                     (year_selected + window_length))
  ]
  dt_use <- dt_use[
    country_name %chin% countries_selected
  ]
  
  # Fill Missing ----
  dt_use <- joyn::merge(
    CJ(
      country_name = dt_use$country_name |> unique(), 
      year         = dt_use$year         |> unique()
    ),
    dt_use, 
    by = c("country_name", "year")
  )
  dt_use[, missing := ifelse(is.na(Indicator), TRUE, FALSE)] # missing indicator
  dt_use <- dt_use[, report := NULL]
  
  # If missing, impute forward or backwards
  setorder(dt_use, country_name, year) # order by year
  dt_forward  <- 
    dt_use[,
           .SD[c((window_length + 1):.N)], 
           by = country_name
           ][
             missing == FALSE
             ][, 
               .(Forward = min(year)-year_selected), 
               by = country_name
               ]
dt_backward <- 
  dt_use[, 
         .SD[c(1:(window_length + 1))], 
         by = country_name
         ][
           missing == FALSE
           ][, 
             .(Backward = abs(max(year)-year_selected)), 
             by = country_name
             ]

dt_use <- joyn::merge(
    dt_use, 
    dt_forward, 
    by = c("country_name"), 
    yvars = T, 
    match_type = "m:1", 
    keep = "left"
  )

  dt_use <- dt_use[, report := NULL]
  dt_use <- joyn::merge(
    dt_use, 
    dt_backward, 
    by = c("country_name"), 
    yvars = T, 
    match_type = "m:1", 
    keep = "left"
  )
  dt_use <- dt_use[, report := NULL]
  dt_use[is.na(Forward), Forward := 100]
  dt_use[is.na(Backward), Backward := 100]
  dt_use[, Impute_Forward := (Backward >= Forward)]
  
  # Do imputation
  dt_use[, 
         Indicator := {
    # Forward fill for Impute_Forward == FALSE
    Indicator[Impute_Forward == FALSE] <- 
      nafill(Indicator[Impute_Forward == FALSE], 
             type = "locf")
    # Backward fill for Impute_Forward == TRUE
    Indicator[Impute_Forward == TRUE] <- 
      nafill(Indicator[Impute_Forward == TRUE], 
             type = "nocb")
    # Return the modified Indicator
    Indicator
  }, by = country_name]
  
  # Keep only selected year
  dt_use <- dt_use[ year == year_selected]
  # Remove columns
  dt_use[, c("Forward", "Backward") := NULL]
  
  setnames(
    dt_use, 
    old = "Indicator", 
    new = tolower(indicator)
  )
  
  # Return
  return(dt_use)
  
}



create_data_imputed_by_countries_two_years <- function(
    dt = dt_pip, 
    countries_selected  = c("South Africa", "Colombia", "United States"), 
    year1_selected      = 1998, 
    year2_selected      = 2005,
    indicator           = c("Gini"), 
    welfare             = NULL, # if 'consumption' or 'income' then use *only* those
    window_length       = 2 
    
){
  dt_use <- copy(dt_pip)
  dt_use <- dt_use[, MeanWelfare := mean]
  # Data in Year 1
  dt1 <- create_data_imputed_by_countries(
    dt                 = dt_use, 
    countries_selected = countries_selected, 
    year_selected      = year1_selected, 
    indicator          = indicator, 
    welfare            = welfare, 
    window_length      = window_length
  )
  indicator <- indicator |> str_replace_all(" ", "_") |> str_to_lower()
  
  setnames(
    dt1, 
    old = tolower(indicator), 
    new = c("Indicator1")
  )
  dt1 <- dt1[, .(country_name, year, Indicator1, MeanWelfare)]

  # Data in Year 2
  dt2 <- create_data_imputed_by_countries(
    dt                 = dt_use, 
    countries_selected = countries_selected, 
    year_selected      = year2_selected, 
    indicator          = indicator, 
    welfare            = welfare, 
    window_length      = window_length
  )
  setnames(
    dt2, 
    old = tolower(indicator), 
    new = c("Indicator2")
  )
  dt2 <- dt2[, .(country_name, year, Indicator2)]
  
  # Join the two years
  dt_use <- joyn::merge(
    dt1, 
    dt2, 
    keep = "left", 
    match_type = "1:1", 
    by = "country_name"
  )
  
  # Find the change in indicator
  dt_use[,report:=NULL]
  dt_use[, Change := Indicator1-Indicator2]
  dt_use[, AnnualizedChange := Change/abs(year2_selected-year1_selected)]
  dt_use[, ChangeColor := ifelse(Change<0, "Negative", "Positive")]
  dt_use[, Change := abs(Change)]
  
  # Change column names back to true indicator names
  # setnames(
  #   dt_use, 
  #   old    = names(dt_use),
  #   new    = gsub(pattern = "Indicator", replacement = indicator, x = names(dt_use))
  # )
  dt_use[, country_name := factor(country_name, levels = country_name[order(Indicator1)])]
  dt_use <- na.omit(dt_use)
  # Return
  return(dt_use)
  
}






```




Change Over Time
===========================================================


Sidebar {.sidebar data-width=250}
-----------------------------------------------------------------------

```{r sidebar-plot-1}
# Select Indicator
selectInput("ineq_indicator", 
            label = "Indicator:",
            choices = c(
              "Mean", 
              "Median", 
              "Mld", 
              "Gini", 
              "Polarization", 
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")
# Select initial year
selectInput("initial_year",
            label    = "Initial Year",
            choices  = dt_pip$year |> unique() |> sort(),
            selected = 1998,
            multiple = FALSE)


# Select initial year
sliderInput("interval", 
             label = "Interval Length: measure the change over how many years?",
             min = 1, max = 10, value = 5, step = 1)

# Select initial year
sliderInput("window", 
             label = "Circa years window",
             min = 0, max = 5, value = 0, step = 1)

```

Column {data-width=900 .tabset .tabset-fade}
-----------------------------------------------------------------------

### 

```{r data-filter-1}
dt_use <- reactive({
  
  dt_use <- create_data_imputed_by_countries_two_years(
    dt = dt_pip, 
    countries_selected  = pip_countries, 
    year1_selected      = as.numeric(input$initial_year), 
    year2_selected      = c(as.numeric(input$initial_year) + as.numeric(input$interval)),
    indicator           = input$ineq_indicator, 
    window_length       = input$window 
)
  
  
})

```

```{r plot1}
renderPlotly({
dt1 <- dt_use()
dt1[
  , 
  MeanWelfare := round(MeanWelfare, 2)
]
  p <- ggplot(
    data = dt1,
  ) +
    geom_segment(
       aes(
         x     = Indicator1,
         xend  = Indicator2,
         y     = country_name,
         yend  = country_name,
         color = ChangeColor
       ), 
       arrow = arrow(length = unit(1.2, "mm"), type = "closed")
    ) +
  geom_point(aes(x = Indicator2, y = country_name, color = ChangeColor
                 ), shape = 2, size = 0.8)+
  geom_point(aes(x = Indicator1, y = country_name, colour = ChangeColor, 
         size = MeanWelfare)) +
  theme_classic()+
  labs(
    title = paste("Change in", input$ineq_indicator, "from", as.numeric(input$initial_year), "to", as.numeric(input$initial_year) + as.numeric(input$interval)),
    subtitle = paste("Countries ordered from highest to lowest by initial", input$ineq_indicator),
    x = paste(input$ineq_indicator),
    y = ""
  )+ 
    theme(legend.position = "none")

  if(input$ineq_indicator %chin% c("Mean", "Median")){
    
  p <- p + 
    scale_color_manual(values = c("Negative" = "darkgreen", "Positive" = "red"))
  } else{
    p <- p + 
      scale_color_manual(values = c("Negative" = "red", "Positive" = "darkgreen"))
  }
  

# Convert to plotly object
pp <- ggplotly(p)

# Loop through each trace to set custom hovertemplate
for (i in 1:length(pp$x$data)) {
  
  # For segments
  if(pp$x$data[[i]]$type == 'scatter' && is.null(pp$x$data[[i]]$mode)) {
    pp$x$data[[i]]$hovertemplate <- paste0(
      "Initial",input$ineq_indicator, ": %{x}<br>",
      "Change: %{xend}<br>",
      "Country: %{y}<br>"
    )
  }
  
  # For points
  if(pp$x$data[[i]]$type == 'scatter' && pp$x$data[[i]]$mode == 'markers') {
    pp$x$data[[i]]$hovertemplate <- paste0(
      input$ineq_indicator, ": %{x}<br>",
      "Country: %{y}<br>"#,
      #"Mean Welfare: %{marker.size}<br>"
    )
  }
}

# Display the plot
pp
})
```





Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Explanation of the chart

```{r}
#h3("Changes in chosen indicator over time")

p("This plot shows the change in the selected indicator over time for countries where there is survey data in the chosen period. The", strong("dot", style = "color:black"), "provides two pieces of information. First, its x-axis position gives the initial indicator value for that country. Second, the dot's size provides the country's mean welfare level in the initial year.  The", strong("horizontal line segments", style = "color:black"), "connects the initial and final year indicator values. The", strong("color", style = "color:black"), "indicates whether a country's outcomes improve over the chosen interval - when mean or median are selected, green means these welfare measures have increased over time. For the remaining indicators, an increase is shown in red, meaning that the inequality has increased. The countries on the y-axis are ordered according to the chosen indicator, where the top country has the largest indicator value in the initial year.")
# 

# 
# strong("the colors of the dots of the line represent the decile to which the country belongs.")
# 
# 
# h3("How to use")
# 
# p("1. Select the indicator.")
# p("2. Select the initial year.")
# p("3. Set the interval length. ")
# p("4. Set the circa years window.")
# 

h4("What if a country has no surveys in the chosen years?")

p("Data might be missing for some countries for these specific years. The imputation procedure works as follows.")
p("1. Initial Year Imputation: If data for the initial year (e.g., 2000) is missing, the algorithm will first look for data in the subsequent year (2000 + 1 = 2001). If the 2001 data is also missing, it will then search in the previous year (2000 - 1 = 1999).")
p("2. End Year: A similar process is applied for the end year (e.g., 2005 if the chosen interval length is 5). First, the algorithm looks for data in 2005 + 1 = 2006 and then 2005 - 1 = 2004 if data for 2005 is missing.")
p("3. Circa years window: The imputation employs a user-defined parameter, the window length to limit the range of years considered for imputation. For example, if the chosen window is 2 then the imputation for the year 2000 will only consider data up to 2002 and down to 1998.")
p("Note this means that if the chosen window is larger than zero, the change in the indicator does not necessarily to the chosen interval length.")



```

Scatterplot of indicators
===========================================================



Sidebar {.sidebar data-width=250}
-----------------------------------------------------------------------

```{r sidebar-plot-2}
# Select Indicator
selectInput("ineq_indicatorX", 
            label = "Indicator x-axis:",
            choices = c(
              "Mean", 
              "Median", 
              "Mld", 
              "Gini", 
              "Polarization", 
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")
# Select Indicator
selectInput("ineq_indicatorY", 
            label = "Indicator y-axis:",
            choices = c(
              "Mean", 
              "Median", 
              "Mld", 
              "Gini", 
              "Polarization", 
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Mean")

checkboxInput("add_line", 
              label = "Add line", 
              value = FALSE)

selectInput("select_reporting_level", 
              label = "Reporting Level", 
              choices = c("All", "National", "Urban", "Rural"), 
              selected = "All"
)


selectInput( "select_welfare_type", 
              label = "Consumption or Income", 
              choices = c("Both", "Consumption", "Income"), 
              selected = "Both"
)

checkboxGroupInput(
  inputId  = "log_transformations", 
  label    = "Log Transformations:", 
  choices  = c("X axis", "Y axis"), 
  selected = NULL
)



selectInput("region_selected",
            label    = "Select regions to highlight",
            choices  = c("All", dt_pip$region_code |> unique() |> sort()),
            selected = "All",
            multiple = TRUE)
# Select region for scatter plot to highlight
selectInput("countries_selected",
            label    = "Select countries to highlight",
            choices  = c(dt_pip$country_name |> unique() |> sort()),
            selected = "",
            multiple = TRUE)

checkboxInput("plot_only_selected_countries",
              label = "Plot only selected countries/regions", 
              value = TRUE
)

```

Column {data-width=1000 .tabset .tabset-fade}
-----------------------------------------------------------------------

```{r data-filter2}



selected_countries <- reactive({
    
  # get list of selected countries
  if(c("All") %chin% input$region_selected){
    
    selected_countries <- dt_pip$country_name |> unique()
    
  } else {
    
    selected_countries <- c(
    (pip_countries_regions[country_name %chin% input$countries_selected])$country_name, 
    (pip_countries_regions[region_code %chin% input$region_selected])$country_name
  ) |> unique()
    
  }
  
  # reporting level
  if(!input$select_reporting_level == c("All")){
    selected_countries <- intersect(
      selected_countries, 
      dt_pip[reporting_level == tolower(input$select_reporting_level)]$country_name
    ) |> unique()
  }else {
    selected_countries
  }
  
    # welfare
  if(!input$select_welfare_type == c("Both")){
    selected_countries <- intersect(
      selected_countries, 
      dt_pip[welfare_type == tolower(input$select_welfare_type)]$country_name
    ) |> unique()
  }else {
    selected_countries
  }
  
  
})


dt_use_sp <- reactive({
  
  # Copy pip stats
  dt_use_sp <- copy(dt_pip)
  
  # Change names of selected indicators
  
  ineq_indic_X <- input$ineq_indicatorX |> str_replace_all(" ", "_") |> str_to_lower()
  ineq_indic_Y <- input$ineq_indicatorY |> str_replace_all(" ", "_") |> str_to_lower()
  
  setnames(
    x = dt_use_sp, 
    old = c(ineq_indic_X, ineq_indic_Y), 
    new = c("IndicatorX", "IndicatorY")
  )
  
  dt_use_sp[
    , 
    Region := region_code
  ]
  
  # Filter
  if(input$plot_only_selected_countries == TRUE){
      filter_countries <- selected_countries()
  dt_use_sp[country_name %chin% filter_countries]
  
    
  }else{dt_use_sp}


    })


```

### 

```{r plot2}

renderPlotly({

  sp1 <- ggplot(dt_use_sp()) +
  labs(
    title = paste("Scatterplot of relationship between", input$ineq_indicatorX, "and", input$ineq_indicatorY),
    x = input$ineq_indicatorX,
    y = input$ineq_indicatorY, 
    color = "Region"
  )
  
  # Log the axes
  if(
    c("Y axis") %chin% input$log_transformations & 
    c("X axis") %chin% input$log_transformations
  ){
   sp1 <- sp1 +
          geom_point(aes(
      x = log(IndicatorX),
      y = log(IndicatorY),
      color = Region
    ))  
   
    # add line
    if(input$add_line == TRUE){
        sp1 <- sp1 +
          geom_smooth(
            aes(
      x = log(IndicatorX),
      y = log(IndicatorY),
      stat = "smooth",
      position = "identity"
            )
          )
  }

    }

  if(
    (c("Y axis") %chin% input$log_transformations) & 
    !(c("X axis") %chin% input$log_transformations)
  ){
    sp1 <- sp1 +
          geom_point(aes(
      x = IndicatorX,
      y = log(IndicatorY),
      color = Region
    ))    
    # add line
    if(input$add_line == TRUE){
        sp1 <- sp1 +
          geom_smooth(
            aes(
      x = IndicatorX,
      y = log(IndicatorY),
      stat = "smooth",
      position = "identity"
            )
          )
  }

  }
  if(
    !(c("Y axis") %chin% input$log_transformations) & 
    (c("X axis") %chin% input$log_transformations)
  ){
    sp1 <- sp1 +
          geom_point(aes(
      x = log(IndicatorX),
      y = IndicatorY,
      color = Region
    ))    # add line
    if(input$add_line == TRUE){
        sp1 <- sp1 +
          geom_smooth(
            aes(
      x = log(IndicatorX),
      y = IndicatorY,
      stat = "smooth",
      position = "identity"
            )
          )
  }

  }
  if(
    !(c("Y axis") %chin% input$log_transformations) & 
    !(c("X axis") %chin% input$log_transformations)
  ){
    sp1 <- sp1 +
          geom_point(aes(
      x = IndicatorX,
      y = IndicatorY,
      color = Region
    ))    # add line
    if(input$add_line == TRUE){
        sp1 <- sp1 +
          geom_smooth(
            aes(
      x = IndicatorX,
      y = IndicatorY,
      stat = "smooth",
      position = "identity"
            )
          )
  }

  }

  if(input$plot_only_selected_countries == FALSE){
    
  # Highlight countries
  sp1 <- sp1 + 
    gghighlight(
      country_name %chin% selected_countries(), 
      unhighlighted_params = list(color = "lightgrey")
    )
    
  }

  sp1 <- sp1 +
  theme_classic() +
  #theme(legend.position = "bottom") + 
    theme(
  axis.title.y = element_text(
    angle = 0,            # Set angle to 0 for horizontal orientation
    #vjust = -1,           # Vertical adjustment
    hjust = 0.5,          # Horizontal adjustment
    #margin = margin(t = 10, r = 0, b = 0, l = 0)  # Margins for positioning
  )
)


# Convert to plotly object
sp1_plotly <- ggplotly(sp1)

# Loop through each trace to set custom hovertemplate
for (i in 1:length(sp1_plotly$x$data)) {
  sp1_plotly$x$data[[i]]$hovertemplate <- paste0(
    input$ineq_indicatorX, ": %{x}<br>",
    input$ineq_indicatorY, ": %{y}<br>"
  )
  sp1_plotly$x$data[[i]]$hoverinfo <- "none" # Suppress default hoverinfo
}

# Display the plot
sp1_plotly

})


```





Column {.tabset .tabset-fade}
-----------------------------------------------------------------------
### Explanation of the chart

```{r}
p("This scatterplot shows the relationship between your two selected inequality indicators. By default, it shows all data, regardless of country, region, reporting level, or whether welfare is measured by consumption or income. Making selections on the side panel will highlight only the relevant data (e.g. selecting SSA as the region and consumption as the welfare measure highlights data for Sub-Saharan Africa where welfare is measured by consumption). If \"Select All Regions\" is ticked, then all countries and regions satisfying the \"Reporting level\" and \"Consumption or Income\" selections will be displayed. The tick box at the bottom of the side panel allows you to plot only the selected data rather than merely highlighting the selected data, removing the grey points.")

p("The plot provides a feature for incorporating a line to depict the underlying relationship between variables. This line represents the conditional mean, estimated via locally estimated scatterplot smoothing (LOESS), and is accompanied by 95% confidence intervals.")

p(strong("Hint:", style = "black"), "Click on the region in the legend to remove from the plot.")
```



Trends
===========================================================



Sidebar {.sidebar data-width=250}
-----------------------------------------------------------------------

```{r sidebar-plot-3}
# Select Indicator
selectInput("ineq_indicatorY_3_fig1", 
            label = "Indicator on y-axis of Figure 1",
            choices = c(
              "Mean", 
              "Median", 
              "Mld", 
              "Gini", 
              "Polarization", 
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Mean")

# Select Indicator
selectInput("ineq_indicatorY_3_fig2", 
            label = "Indicator on y-axis of Figure 2",
            choices = c(
              "Mean", 
              "Median", 
              "Mld", 
              "Gini", 
              "Polarization", 
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected = "Gini")

checkboxInput("log_y_3_fig1", 
              label = "Log Y axis in Figure 1",  
              value = FALSE)

checkboxInput("log_y_3_fig2", 
              label = "Log Y axis in Figure 2",  
              value = FALSE)

# Select region for scatter plot to highlight
selectInput("countries_selected_3",
            label    = "Select countries to highlight",
            choices  = c(dt_pip$country_name |> unique() |> sort()),
            selected = c("South Africa", "Colombia", "United States"),
            multiple = TRUE)

```



```{r data-filter3}

dt_trend_plot1 <- reactive({
  
  # Copy data table
  dt_trend_plot <- copy(dt_pip)
  
  # rename
 
  
  # Filter for selected countries
  dt_trend_plot <- dt_trend_plot[
     country_name %chin% input$countries_selected_3
  ]
  
  # Rename
  setnames(
    dt_trend_plot, 
    old = tolower(input$ineq_indicatorY_3_fig1), 
    new = "IndicatorY"
  )
  
  
  
  
})


dt_trend_plot2 <- reactive({
  
  # Copy data table
  dt_trend_plot <- copy(dt_pip)
  
  # rename
 
  
  # Filter for selected countries
  dt_trend_plot <- dt_trend_plot[
     country_name %chin% input$countries_selected_3
  ]
  
  # Rename
  setnames(
    dt_trend_plot, 
    old = tolower(input$ineq_indicatorY_3_fig2), 
    new = "IndicatorY"
  )
  
  
  
  
})

```


Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Figure 1

```{r plot3}

renderPlotly({
  
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot1()

# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorY) - min(IndicatorY)), by = country_name]
first_points = dt[, .SD[which.min(year)], by = country_name]
first_points = first_points[dt, on = .(country_name), nomatch = 0]


# Initialize ggplot object
tp1 <- ggplot(dt) +
  labs(
    title = paste(input$ineq_indicatorY_3_fig1, "over time"), 
    subtitle = "Selected countries", 
    x = "Year", 
    y = input$ineq_indicatorY_3_fig1
  ) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig1 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_point(aes(x = round(year), y = transformation(IndicatorY), color = country_name), size = 2) +
  geom_line(aes(x = round(year), y = transformation(IndicatorY), color = country_name, group = comparable_spell), size = 1)  + 
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points, 
            aes(x = year, y = transformation(IndicatorY - rel_nudge_y), label = country_name, color = country_name),
            size = 3.5)

dt_trend_plotly <- ggplotly(tp1)

# Loop through traces to update hovertemplate
for (i in 1:length(dt_trend_plotly$x$data)) {
  dt_trend_plotly$x$data[[i]]$hovertemplate <- paste0(
    "Year: %{x}<br>",
    input$ineq_indicatorY_3_fig1, ": %{y}<br>"#,
    #"Country: %{text}"
  )
 # dt_trend_plotly$x$data[[i]]$text <- dt_trend_plotly$x$data[[i]]$meta$country_name
}

dt_trend_plotly


})

```


Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Figure 2

```{r plot3-2}

renderPlotly({
  
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot2()

# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorY) - min(IndicatorY)), by = country_name]
first_points = dt[, .SD[which.min(year)], by = country_name]
first_points = first_points[dt, on = .(country_name), nomatch = 0]


# Initialize ggplot object
tp1 <- ggplot(dt) +
  labs(
    title = paste(input$ineq_indicatorY_3_fig2, "over time"), 
    subtitle = "Selected countries", 
    x = "Year", 
    y = input$ineq_indicatorY_3_fig2
  ) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig2 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_point(aes(x = year, y = transformation(IndicatorY), color = country_name), size = 2) +
  geom_line(aes(x = year, y = transformation(IndicatorY), color = country_name, group = comparable_spell), size = 1)  + 
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points, 
            aes(x = year, y = transformation(IndicatorY - rel_nudge_y), label = country_name, color = country_name),
            size = 3.5)

dt_trend_plotly <- ggplotly(tp1)

# Loop through traces to update hovertemplate
for (i in 1:length(dt_trend_plotly$x$data)) {
  dt_trend_plotly$x$data[[i]]$hovertemplate <- paste0(
    "Year: %{x}<br>",
    input$ineq_indicatorY_3_fig2, ": %{y}<br>"#,
    #"Country: %{text}"
  )
 # dt_trend_plotly$x$data[[i]]$text <- dt_trend_plotly$x$data[[i]]$meta$country_name
}

dt_trend_plotly

})

```







Table of Indicators
===========================================================


Sidebar {.sidebar data-width=250}
-----------------------------------------------------------------------

```{r sidebar-table-1}

# Select Indicator
checkboxGroupInput("ineq_indicator_table", 
            label = "Indicators:",
            choices = c(
              "Mean", 
              "Median", 
              "Gini",
              "MLD",
              "Decile Shares",
              "Top 10 Bottom 40 Ratio", 
              "Top 20 Bottom 20 Ratio"
            ),
            selected =  c(
              "Mean", 
              "Gini",
              "Top 10 Bottom 40 Ratio"
            ))


selectInput("select_countries_table", 
            label = "Countries:",
            choices = c(
              "All", 
              dt_pip$region_name |> 
                unique() |> 
                sort(),  
              pip_countries
            ),
            selected = c("All"), 
            multiple = TRUE)

# selectInput("regions_table", 
#             label = "Regions:",
#             choices = dt_pip$region_code |> unique(),
#             selected = "", 
#             multiple = TRUE)

radioButtons("all_years_table", 
                   label = "Years shown in table",  
                   choices = c(
                     "Latest", 
                     "All", 
                     "Custom"
                   ), 
                   selected = c("Latest"))


conditionalPanel(
  condition = "input.all_years_table == 'Custom'",
  selectInput("select_initial_year_table", 
              label = "Initial Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_table == 'Custom' && input.select_initial_year_table != null",
  selectInput("select_final_year_table", 
              label = "Final Year:",
              choices = dt_pip$year |> 
                unique() |> 
                sort(),
              selected = dt_pip$year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_table, 
             {
               updated_choices <- dt_pip[
                 year > as.numeric(input$select_initial_year_table), 
                 unique(year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_table", 
                 choices = updated_choices, 
                 selected = dt_pip$year |> max() 
               )
})


# Render download button
#downloadButton("downloadData", "Download CSV")
downloadLink(
  outputId = "downloadData", 
  label = "Download as csv"
)


```




Row {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 

```{r plot-table}


make_table_across_countries <- function(
    dt,
    country_name_vec = c("Angola", "South Africa"),
    ineq_indicators  = c(
      "Mean",
      "Median",
      "Mld",
      "Gini",
      "Decile1",
      "Decile2",
      "Decile3",
      "Decile4",
      "Decile5",
      "Decile6",
      "Decile7",
      "Decile8",
      "Decile9",
      "Decile10",
      "Top_10_bottom_40_ratio",
      "Top_20_bottom_20_ratio"
    ),
    years_selected = c("All", "Latest", "Custom"), 
    start_year = NULL, 
    end_year = NULL
){
  dt <- copy(dt)
  # Check Inputs ----
  stopifnot(is.data.table(dt))
  stopifnot(country_name_vec %chin% pip_countries)
  years_selected <- match.arg(years_selected)

  # If decile shares is selected
  if(c("Decile Shares") %chin% ineq_indicators ){
    # remove "Decile Shares" element
    ineq_indicators <- ineq_indicators[!c("Decile Shares") %chin% ineq_indicators]
    # add all individual decile shares
    ineq_indicators <- c(
      ineq_indicators, 
      paste0("decile", 1:10)
    )
  }
  
  # Prepare Data ----
  selected_cols <- c(
    "Country",
    "Region",
    #"Region_code",
    "Year",
    "Reporting_level",
    "Welfare_type",
    ineq_indicators
  )
  selected_cols <- 
    selected_cols |> 
    str_replace_all(" ", "_") |> 
    str_to_lower() |> 
    str_to_title()
  
  setnames(
    dt,
    old = c("country_name", "region_name"),
    new = c("country", "region")                           # Clean variable names
  )
  setnames(
    dt,
    stringr::str_to_title(names(dt))             # Capitalize column names
  )
  
  
  dt <- dt[
    Country %chin% country_name_vec,         # filter by country
    ..selected_cols                             # Select id vars and inequality indicators
  ]
  
  dt[
    ,
    (names(dt)) := lapply(                       # Round to 2 decimals
      .SD,
      \(x){
        if (is.numeric(x)) 
          round(x, 2) 
        else 
          x
        }
    )
  ]
  
  
  # Filter years
  if(years_selected == "Latest"){
    dt <- dt[, 
             .SD[which.max(Year)], 
             by = Country]
  }
  if(years_selected == "Custom"){

    if(start_year > end_year)
      stop("Please note the initial year must be lower than the final year")
    dt <- dt[
      Year >= start_year &
        Year <= end_year
    ]

  }
  
  
  setorder(dt, Country, Region, -Year, Reporting_level, Welfare_type)
  
  setnames(
    dt, 
    old = c("Welfare_type"), 
    new = c("Survey_type")
  )
  dt # return
} # end of make_table_across_countries()



table <-
  reactive({
    
    # Filter countries
    
    ct <- 
      if ("All" %chin% input$select_countries_table) {
      pip_countries
    } else {
      c(pip_countries_regions[country_name %chin%
                                input$select_countries_table]$country_name,
        pip_countries_regions[region_name %chin%
                                input$select_countries_table]$country_name
        ) |>
        unique()
    }
    
    make_table_across_countries(
      dt               = dt_pip,
      country_name_vec = ct,
      ineq_indicators  = input$ineq_indicator_table,
      years_selected   = input$all_years_table, 
      start_year       = input$select_initial_year_table, 
      end_year         = input$select_final_year_table
  )
})

  

renderPlotly({
  
list_of_columns <- lapply(
    names(table()), 
    \(col_name) { # Make the columns list items for plotly
      return(table()[[col_name]])
    })
  
  # plot table
  t <- plot_ly(
    type = 'table',
    #columnwidth = c(100, 100),
    header = list(
      values = table() |> 
        colnames() |> 
        # column names vector
        str_replace_all(pattern = "_", 
                        replacement = " "), 
      align = "center",
      line = list(width = 1, color = 'black'),
      fill = list(color = c("grey", "grey")),
      font = list(family = "Arial", size = 14, color = "white")
    ),
    cells = list(
      values = list_of_columns,
      align  = c("center", "center"),
      line   = list(color = "black", width = 1),
      font   = list(family = "Arial", size = 12, color = c("black"))
    ))
  
t <- layout(
  t,
  title   = "PIP Key Inequality Indicators, Selected Country and Years",
  titlefont = list(color = 'black'), 
  title_x = 0 
)
  
  t
  
})



output$downloadData <- downloadHandler(
  filename = function() {
    paste("PIP-key-ineq-indicators_", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(table(), file)
  }
)



```


Source: this is the data source

